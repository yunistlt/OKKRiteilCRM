
import { supabase } from '@/utils/supabase';

export interface Rule {
    code: string;
    entity_type: 'call' | 'order' | 'event';
    condition_sql: string;
    params: Record<string, any>;
    severity: string;
}

/**
 * Execute all active rules against a time range.
 * Currently supports 'call' entity type fully.
 */
export async function runRuleEngine(startDate: string, endDate: string, targetRuleId?: number) {
    console.log(`[RuleEngine] Running for range ${startDate} to ${endDate} ${targetRuleId ? `(Target Rule: ${targetRuleId})` : ''}`);

    // 1. Fetch Active Rules
    let query = supabase
        .from('okk_rules')
        .select('*')
        .eq('is_active', true);

    if (targetRuleId) {
        query = query.eq('id', targetRuleId);
    }

    const { data: rules, error } = await query;

    if (error || !rules) {
        console.error('[RuleEngine] Failed to fetch rules:', error);
        return;
    }

    console.log(`[RuleEngine] Found ${rules.length} active rules.`);

    console.log(`[RuleEngine] Found ${rules.length} active rules.`);

    // 2. Execute per entity type
    let totalViolations = 0;
    for (const rule of rules) {
        try {
            if (rule.entity_type === 'call') {
                totalViolations += await executeCallRule(rule, startDate, endDate);
            } else if (rule.entity_type === 'event') {
                totalViolations += await executeEventRule(rule, startDate, endDate);
            } else {
                console.log(`[RuleEngine] Skipping unsupported entity type: ${rule.entity_type} (${rule.code})`);
            }
        } catch (e) {
            console.error(`[RuleEngine] Error executing rule ${rule.code}:`, e);
        }
    }
    return totalViolations;
}

async function executeEventRule(rule: any, startDate: string, endDate: string): Promise<number> {
    // Queries raw_order_events (history)
    let query = supabase
        .from('raw_order_events')
        .select(`
            event_id,
            event_type,
            raw_payload,
            occurred_at,
            retailcrm_order_id,
            order_metrics!left ( current_status, manager_id, full_order_context )
        `)
        .gte('occurred_at', startDate)
        .lte('occurred_at', endDate);

    const params = rule.parameters || {};

    // Basic SQL Simulation (Same workaround as Call Rule for now until RPC)
    // "field_name = 'status'"
    // "new_value = 'cancel'"

    // We cannot reliably parse complex SQL here without an RPC function `execute_rule_logic`.
    // However, given the User's example: 
    // "field_name = 'status' AND (om.full_order_context->>'manager_comment' IS NULL)"

    // Approach: Fetch ALL events in range (usually small per minute), then filter in Memory.
    // This allows full JS evaluation of the JSON context.

    const { data: events, error } = await query;
    if (error) {
        console.error(`Error fetching events for ${rule.code}:`, error);
        return 0;
    }

    if (!events || events.length === 0) return 0;

    // In-Memory Filter (Safe Evaluator)
    const violations = events.filter((e: any) => {
        // Construct a context object "om" to match the SQL/AI expectation
        const om = {
            current_status: e.order_metrics?.current_status,
            full_order_context: e.order_metrics?.full_order_context || {},
            manager_id: e.order_metrics?.manager_id
        };
        const rawValue = e.raw_payload?.newValue;
        const normalizedValue = (typeof rawValue === 'object' && rawValue !== null && 'code' in rawValue)
            ? rawValue.code
            : rawValue;

        const row = {
            field_name: (e.event_type === 'status_changed' || e.raw_payload?.field === 'status') ? 'status' : e.event_type,
            new_value: normalizedValue,
            occurred_at: e.occurred_at,
            om
        };

        // Parse specific known conditions or use a safe eval if possible?
        // JS 'eval' is dangerous. 
        // For now, let's look for specific patterns generated by our AI.

        // Pattern 1: Status Change + Empty Comment
        // SQL: field_name = 'status' AND (om.full_order_context->>'manager_comment' IS NULL ...)

        if (rule.condition_sql.includes("field_name = 'status'") && rule.condition_sql.includes("manager_comment")) {
            if (row.field_name !== 'status') return false;
            const comment = om.full_order_context?.manager_comment;
            // Check if comment is empty
            if (!comment || comment.trim() === '') return true; // Violation!
            return false;
        }

        return false;
    });

    if (violations.length > 0) {
        console.log(`[${rule.code}] Found ${violations.length} event violations.`);

        const records = violations.map((v: any) => ({
            rule_code: rule.code,
            order_id: v.retailcrm_order_id,
            violation_time: v.occurred_at,
            severity: rule.severity,
            details: `Event Rule Match: ${rule.name}`
        }));

        const { error: insError } = await supabase
            .from('okk_violations')
            .upsert(records, { onConflict: 'rule_code, order_id, violation_time' }); // Ensure unique constraint handles this

        if (insError) console.error(`Error saving violations for ${rule.code}:`, insError);
        return violations.length;
    }
    return 0;
}

async function executeCallRule(rule: any, startDate: string, endDate: string): Promise<number> {
    // 1. Construct Query
    // We need to inject parameters into the SQL or handle them via Supabase filter.
    // Supabase JS .filter() takes a column, operator, and value.
    // It doesn't support arbitrary SQL "WHERE condition".
    // ...Wait. Supabase JS client wraps PostgREST.
    // PostgREST doesn't support raw SQL injection in WHERE for security.

    // PROBLEM: Storing raw SQL `duration < (params->>'threshold')::int` in DB is great for SQL execution,
    // but hard to execute via supabase-js client side without an RPC function.

    // SOLUTION: Use an RPC function that takes the condition_sql? unsafe.
    // OR: Use strict filters in JSON? e.g. { "operator": "lt", "column": "duration", "value_param": "threshold" }
    // OR: Since we are running on Backend (or "Trusted Environment"), we can use the `postgres` driver ? 
    // No, we stick to supabase-js.

    // Workaround: We can't trust the client to parse random SQL. 
    // BUT! All our current rules are simple.
    // Let's implement a safe parser for our specific use case, OR use an RPC `execute_rule`.

    // RPC APPROACH is best. "execute_rule(rule_code, start_date, end_date)"
    // logic inside SQL function:
    //   SELECT * FROM raw_telphin_calls WHERE [condition injected] AND timestamp BETWEEN ...

    // BUT creating dynamic SQL functions requires a migration.
    // Let's try to simulate checking in code for now (fetch all, filter in memory) 
    // UNLESS the dataset is huge.
    // For "range", fetching all calls is acceptable (e.g. daily batch).
    // Let's fetch calls ONCE, then filter in code using Function constructor? Unsafe.
    // Using a simple evaluator.

    // Let's implement a pragmatic "Code Interpreter" for our rules.
    // We fetch calls, then we check:
    // if (evaluate(rule.condition_sql, call)) ...

    // Actually, `condition_sql` in the DB was defined as:
    // "duration >= 5 AND duration < (params->>'threshold_sec')::int"
    // This is purely Postgres syntax. It won't work in JS `eval`.

    // RE-DECISION: To make the "Rule Engine" real, it should run in the DB.
    // I will generate an RPC function `execute_call_rule` in the next migration.
    // This function will take a `where_clause` text and run it via `EXECUTE`.

    // For now (Step 1), I will implement logic here to PROVE it works, 
    // by manually "transpiling" the known SQL patterns to Supabase filters.

    // Updated for RAW Schema: raw_telphin_calls
    // Columns: event_id, duration_sec, started_at, is_answering_machine (missing in RAW, assuming false for now)

    let query = supabase
        .from('raw_telphin_calls')
        // We select 'event_id' as 'id', 'duration_sec' as 'duration', 'started_at' as 'timestamp' 
        // to match the code expectations locally, or just rename in logic.
        // Let's select properly.
        .select('event_id, duration_sec, started_at')
        .gte('started_at', startDate)
        .lte('started_at', endDate);

    const params = rule.parameters || {};

    // Mapping: 
    // duration -> duration_sec
    // timestamp -> started_at
    // id -> event_id

    // Manual transpiler for known patterns (Temporary Code Engine)
    // "duration < (params->>'threshold_sec')::int"  ->  .lt('duration', params.threshold_sec)
    // "flow = 'incoming'" -> .eq('flow', 'incoming')

    if (rule.code === 'short_call') {
        query = query
            .gte('duration_sec', 5)
            .lt('duration_sec', params.threshold_sec);
    }
    else if (rule.code === 'missed_incoming') {
        query = query
            .eq('direction', 'incoming')
            .eq('duration_sec', 0);
    }
    else if (rule.code === 'answering_machine_dialog') {
        // AMD not yet in RAW. Skipping for now to avoid errors.
        console.log('[RuleEngine] Skipping answering_machine_dialog (AMD data not ready)');
        return 0;
    }
    else if (rule.code === 'call_impersonation') {
        query = query
            .gt('duration_sec', 0)
            .lt('duration_sec', params.threshold_sec);
        // .neq('is_answering_machine', true); // Skipped
    }

    const { data: calls, error } = await query;

    if (error) {
        console.error(`Error fetching calls for ${rule.code}:`, error);
        return 0;
    }

    if (!calls || calls.length === 0) return 0;

    console.log(`[${rule.code}] Found ${calls.length} violations.`);

    // Insert Violations
    const violations = calls.map(c => ({
        rule_code: rule.code,
        call_id: c.event_id, // INT8
        violation_time: c.started_at,
        severity: rule.severity,
        details: `Detected by rule ${rule.name}`
    }));

    // Bulk upsert
    const { error: insError } = await supabase
        .from('okk_violations')
        .upsert(violations, { onConflict: 'rule_code, call_id' });

    if (insError) console.error(`Error saving violations for ${rule.code}:`, insError);
    return violations.length;
}
